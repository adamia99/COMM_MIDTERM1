import psycopg2
from psycopg2.extras import execute_values
from faker import Faker
import random
import uuid
import sys
import time

# ---------------- CONFIG ----------------
DB_CONFIG = {
    "host": "localhost",
    "port": 5433,
    "database": "postgres",
    "user": "postgres",
    "password": "postgres"
}

# --- VOLUME CONFIG ---
NUM_ROWS_PT = 1_000_000
NUM_ROWS_ACC = 1_000_000
NUM_ROWS_TRN = 1_000_000
BATCH_SIZE = 10_000

fake = Faker()


# ---------------- GENERATE PT (Person Table) ----------------
def generate_pt(conn, num_rows):
    """Generates and inserts person data, returning the generated pt_keys."""
    pt_keys = []
    print(f"  Starting generation for {num_rows:,} rows...")
    start_time = time.time()

    with conn.cursor() as cur:
        for start in range(0, num_rows, BATCH_SIZE):
            batch = []
            end = min(start + BATCH_SIZE, num_rows)

            for i in range(start, end):
                first_name = fake.first_name()
                last_name = fake.last_name()
                # Use a combined random/sequential string for the person_id column
                person_id = f"P{random.randint(1000, 9999)}_{i:06d}"
                birth_date = fake.date_of_birth(minimum_age=18, maximum_age=90)
                batch.append((first_name, last_name, person_id, birth_date))

            # Use execute_values with RETURNING to get the actual IDs generated by the database
            try:
                result = execute_values(
                    cur,
                    "INSERT INTO pt(first_name, last_name, person_id, birth_date) VALUES %s RETURNING pt_key",
                    batch,
                    fetch=True
                )

                # Store the actual primary keys
                pt_keys.extend([r[0] for r in result])

                if (start + BATCH_SIZE) % 100_000 == 0:
                    sys.stdout.write(
                        f"\r  Progress: {(start + BATCH_SIZE):,} rows inserted ({time.time() - start_time:.2f}s)")
                    sys.stdout.flush()

            except Exception as e:
                print(f"\n[ERROR] Failed to insert PT batch at row {start}: {e}")
                conn.rollback()
                raise

    conn.commit()
    end_time = time.time()
    print(f"\r  Finished PT generation. Total time: {end_time - start_time:.2f}s")
    return pt_keys


# ---------------- GENERATE ACC (Account Table) ----------------
def generate_acc(conn, num_rows, pt_keys):
    """Generates and inserts account data, returning account keys and their currency map."""
    ccy_keys = [1, 2, 3]  # EUR, USD, GEL
    acc_stat_keys = [1, 2, 3]  # active, closed, blocked
    acc_keys = []
    acc_ccy_map = {}
    print(f"  Starting generation for {num_rows:,} rows...")
    start_time = time.time()

    with conn.cursor() as cur:
        for start in range(0, num_rows, BATCH_SIZE):
            batch = []
            end = min(start + BATCH_SIZE, num_rows)
            for i in range(start, end):
                # We are now guaranteed that pt_key exists
                pt_key = random.choice(pt_keys)
                acc_stat_key = random.choice(acc_stat_keys)
                ccy_key = random.choice(ccy_keys)

                # FIX: Use UUID to ensure unique account numbers
                unique_suffix = uuid.uuid4().hex[:14].upper()
                acc_num = f"ACC{unique_suffix}"

                activation_date = fake.date_between(start_date='-5y', end_date='today')
                # 20% chance of being closed
                close_date = None
                if random.random() < 0.2 and acc_stat_key == 2:  # Only closed if status is 'closed'
                    close_date = fake.date_between(activation_date, 'today')
                elif acc_stat_key != 2:  # Ensure open if status is not 'closed'
                    close_date = None

                batch.append((pt_key, acc_stat_key, ccy_key, acc_num, activation_date, close_date))

            # Use RETURNING to fetch the generated acc_key and the ccy_key for transaction mapping
            try:
                result = execute_values(
                    cur,
                    """INSERT INTO acc(pt_key, acc_stat_key, ccy_key, acc_num, activation_date, close_date)
                       VALUES %s RETURNING acc_key, ccy_key""",
                    batch,
                    fetch=True
                )

                # Store actual IDs and map them: acc_key -> ccy_key
                for new_acc_id, used_ccy in result:
                    acc_keys.append(new_acc_id)
                    acc_ccy_map[new_acc_id] = used_ccy

                if (start + BATCH_SIZE) % 100_000 == 0:
                    sys.stdout.write(
                        f"\r  Progress: {(start + BATCH_SIZE):,} rows inserted ({time.time() - start_time:.2f}s)")
                    sys.stdout.flush()

            except Exception as e:
                print(f"\n[ERROR] Failed to insert ACC batch at row {start}: {e}")
                conn.rollback()
                raise

    conn.commit()
    end_time = time.time()
    print(f"\r  Finished ACC generation. Total time: {end_time - start_time:.2f}s")
    return acc_keys, acc_ccy_map


# ---------------- GENERATE TRN (Transaction Table) ----------------
def generate_trn(conn, num_rows, acc_keys, acc_ccy_map):
    """Generates and inserts transaction data."""
    print(f"  Starting generation for {num_rows:,} rows...")
    start_time = time.time()

    with conn.cursor() as cur:
        for start in range(0, num_rows, BATCH_SIZE):
            batch = []
            end = min(start + BATCH_SIZE, num_rows)
            for i in range(start, end):
                trn_date = fake.date_time_between(start_date='-2y', end_date='now')

                # Pick Credit Account
                cr_acc_key = random.choice(acc_keys)

                # FIX: Pick Debit Account, ensuring it is NOT the same as Credit
                db_acc_key = random.choice(acc_keys)
                # Retry until different
                while db_acc_key == cr_acc_key:
                    db_acc_key = random.choice(acc_keys)

                # Get the currency of the Credit Account (or Debit, assuming same ccy for simplicity)
                trn_ccy_key = acc_ccy_map[cr_acc_key]
                trn_amt = round(random.uniform(1, 10000), 2)
                description = fake.sentence()
                batch.append((trn_date, cr_acc_key, db_acc_key, trn_ccy_key, trn_amt, description))

            try:
                execute_values(
                    cur,
                    "INSERT INTO trn(trn_date, cr_acc_key, db_acc_key, trn_ccy_key, trn_amt, description) VALUES %s",
                    batch
                )

                if (start + BATCH_SIZE) % 100_000 == 0:
                    sys.stdout.write(
                        f"\r  Progress: {(start + BATCH_SIZE):,} rows inserted ({time.time() - start_time:.2f}s)")
                    sys.stdout.flush()

            except Exception as e:
                print(f"\n[ERROR] Failed to insert TRN batch at row {start}: {e}")
                conn.rollback()
                raise

    conn.commit()
    end_time = time.time()
    print(f"\r  Finished TRN generation. Total time: {end_time - start_time:.2f}s")


# ---------------- MAIN ----------------
def main():
    conn = None
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        conn.autocommit = False  # Ensure atomicity for large batches
        print("Connected to PostgreSQL database.")
        print("-" * 30)

        print("STAGE 1: Generating PT (Person) Data...")
        pt_keys = generate_pt(conn, NUM_ROWS_PT)
        print(f"SUCCESS: Generated and verified {len(pt_keys):,} PT keys.")
        print("-" * 30)

        print("STAGE 2: Generating ACC (Account) Data...")
        # Note: acc_keys will be shorter than pt_keys if NUM_ROWS_ACC < NUM_ROWS_PT
        acc_keys, acc_ccy_map = generate_acc(conn, NUM_ROWS_ACC, pt_keys)
        print(f"SUCCESS: Generated and verified {len(acc_keys):,} ACC keys.")
        print("-" * 30)

        print("STAGE 3: Generating TRN (Transaction) Data...")
        generate_trn(conn, NUM_ROWS_TRN, acc_keys, acc_ccy_map)
        print(f"SUCCESS: Inserted {NUM_ROWS_TRN:,} TRN rows.")
        print("-" * 30)

        print("All data insertion completed successfully!")

    except psycopg2.Error as e:
        print("\n\n--- A DATABASE ERROR OCCURRED ---")
        print(f"Error Type: {type(e).__name__}")
        print(f"Details: {e}")
        if conn:
            conn.rollback()
        sys.exit(1)
    except Exception as e:
        print("\n\n--- A GENERAL ERROR OCCURRED ---")
        print(f"Error Type: {type(e).__name__}")
        print(f"Details: {e}")
        sys.exit(1)
    finally:
        if conn:
            conn.close()
            print("Connection closed.")


if __name__ == "__main__":
    main()